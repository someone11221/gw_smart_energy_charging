from __future__ import annotations\nfrom typing import Any, Dict, List\nimport logging\nimport json\nfrom datetime import timedelta, datetime\n\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.config_entries import ConfigEntry\nfrom homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n\nfrom .const import (\n    DEFAULT_SCAN_INTERVAL,\n    CONF_FORECAST_SENSOR,\n    CONF_PRICE_SENSOR,\n    CONF_PV_POWER_SENSOR,\n    CONF_GOODWE_SWITCH,\n    CONF_SOC_SENSOR,\n    CONF_BATTERY_CAPACITY,\n    CONF_MAX_CHARGE_POWER,\n    CONF_CHARGE_EFFICIENCY,\n    CONF_MIN_RESERVE,\n    CONF_ENABLE_AUTOMATION,\n    CONF_SWITCH_ON_MEANS_CHARGE,\n)\n\n_LOGGER = logging.getLogger(__name__)\n\ndef _parse_hourly_from_state(state) -> List[float]:\n    if state is None:\n        return []\n    # Try JSON list in state\n    try:\n        data = json.loads(state.state)\n        if isinstance(data, list) and len(data) >= 24:\n            return [float(x) for x in data[:24]]\n    except Exception:\n        pass\n    # Try attributes\n    for k in ("forecast", "hourly", "hours", "values", "tomorrow", "prices"):\n        if state.attributes and k in state.attributes:\n            val = state.attributes[k]\n            if isinstance(val, list) and len(val) >= 24:\n                try:\n                    return [float(x) for x in val[:24]]\n                except Exception:\n                    continue\n    # CSV fallback\n    if isinstance(state.state, str) and "," in state.state:\n        parts = [p.strip() for p in state.state.split(",")]\n        if len(parts) >= 24:\n            try:\n                return [float(x) for x in parts[:24]]\n            except Exception:\n                pass\n    return []\n\nclass GWSmartCoordinator(DataUpdateCoordinator):\n    def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:\n        self.hass = hass\n        self.entry = entry\n        self.config = entry.data\n        super().__init__(hass, _LOGGER, name="gw_smart_charging", update_interval=timedelta(seconds=DEFAULT_SCAN_INTERVAL))\n        self.forecast: List[float] = []\n        self.prices: List[float] = []\n        self.schedule: Dict[int, Dict[str, Any]] = {}\n\n    async def _async_update_data(self) -> Dict[str, Any]:\n        try:\n            forecast_entity = self.config.get(CONF_FORECAST_SENSOR)\n            price_entity = self.config.get(CONF_PRICE_SENSOR)\n            pv_entity = self.config.get(CONF_PV_POWER_SENSOR)\n            soc_entity = self.config.get(CONF_SOC_SENSOR)\n            goodwe_switch = self.config.get(CONF_GOODWE_SWITCH)\n\n            state_fore = self.hass.states.get(forecast_entity) if forecast_entity else None\n            state_price = self.hass.states.get(price_entity) if price_entity else None\n            state_pv = self.hass.states.get(pv_entity) if pv_entity else None\n            state_soc = self.hass.states.get(soc_entity) if soc_entity else None\n\n            forecast = _parse_hourly_from_state(state_fore)\n            prices = _parse_hourly_from_state(state_price)\n\n            self.forecast = forecast\n            self.prices = prices\n\n            # Read SOC numeric\n            current_soc = None\n            if state_soc and state_soc.state not in (None, ""):\n                try:\n                    current_soc = float(state_soc.state)\n                except Exception:\n                    current_soc = None\n\n            battery_capacity = float(self.config.get(CONF_BATTERY_CAPACITY, 17))\n            max_charge_power = float(self.config.get(CONF_MAX_CHARGE_POWER, 3.7))\n            efficiency = float(self.config.get(CONF_CHARGE_EFFICIENCY, 0.95))\n            min_reserve = float(self.config.get(CONF_MIN_RESERVE, 10)) / 100.0\n            enable_automation = bool(self.config.get(CONF_ENABLE_AUTOMATION, False))\n\n            schedule: Dict[int, Dict[str, Any]] = {}\n\n            if len(forecast) >= 24 and len(prices) >= 24 and current_soc is not None:\n                required_kwh = max(0.0, battery_capacity * ((100.0 - current_soc) / 100.0))\n                # Reserve\n                required_kwh = max(0.0, required_kwh - battery_capacity * min_reserve)\n\n                # prepare hour infos\n                hours = list(range(24))\n                hour_infos = []\n                for h in hours:\n                    pv_kw = float(forecast[h])\n                    price = float(prices[h])\n                    hour_infos.append({"hour": h, "pv_kw": pv_kw, "price": price})\n\n                # allocate PV contributions first (we assume PV kW for hour equals kWh potential)\n                pv_threshold = 0.1\n                pv_hours = [h for h in hour_infos if h["pv_kw"] > pv_threshold]\n                pv_energy_est = sum(h["pv_kw"] for h in pv_hours)  # approximate kWh available\n\n                remaining_needed = max(0.0, required_kwh - pv_energy_est)\n\n                # sort remaining hours (non-pv) by price ascending\n                non_pv_hours = [h for h in hour_infos if h["pv_kw"] <= pv_threshold]\n                non_pv_sorted = sorted(non_pv_hours, key=lambda x: x["price"])\n\n                planned_grid: Dict[int, float] = {}\n                for h in non_pv_sorted:\n                    if remaining_needed <= 0:\n                        break\n                    available = max_charge_power * efficiency\n                    take = min(available, remaining_needed)\n                    planned_grid[h["hour"]] = take\n                    remaining_needed -= take\n\n                for h in hour_infos:\n                    mode = "idle"\n                    planned_kwh = planned_grid.get(h["hour"], 0.0)\n                    if h["pv_kw"] > pv_threshold:\n                        mode = "pv"\n                    if planned_kwh > 0:\n                        mode = "grid"\n                    schedule[h["hour"]] = {\n                        "mode": mode,\n                        "pv_kw": round(h["pv_kw"], 3),\n                        "price": round(h["price"], 6),\n                        "planned_grid_kwh": round(planned_kwh, 3),\n                    }\n            else:\n                now = datetime.utcnow().hour\n                schedule[now] = {\n                    "mode": "idle",\n                    "pv_kw": float(state_pv.state) if state_pv and state_pv.state not in (None, "") else 0.0,\n                    "price": float(state_price.state) if state_price and state_price.state not in (None, "") else 0.0,\n                    "planned_grid_kwh": 0.0,\n                }\n\n            self.schedule = schedule\n\n            result = {\n                "forecast": self.forecast,\n                "prices": self.prices,\n                "schedule": self.schedule,\n                "timestamp": datetime.utcnow().isoformat(),\n                "goodwe_switch": goodwe_switch,\n                "current_soc": current_soc,\n            }\n            return result\n        except Exception as err:\n            raise UpdateFailed(err)\n\n    async def apply_current_hour(self) -> None:\n        cfg = self.entry.data\n        goodwe_switch = cfg.get(CONF_GOODWE_SWITCH)\n        switch_on_means_charge = cfg.get(CONF_SWITCH_ON_MEANS_CHARGE, True)\n        enable_automation = cfg.get(CONF_ENABLE_AUTOMATION, False)\n        if not enable_automation or not goodwe_switch:\n            _LOGGER.debug("Automation disabled or no goodwe switch configured")\n            return\n\n        now_hour = datetime.utcnow().hour\n        hour_info = self.schedule.get(now_hour)\n        if not hour_info:\n            _LOGGER.debug("No schedule for hour %s", now_hour)\n            return\n\n        desired_mode = hour_info.get("mode")\n        try:\n            if desired_mode == "grid":\n                if switch_on_means_charge:\n                    await self.hass.services.async_call("switch", "turn_on", {"entity_id": goodwe_switch})\n                else:\n                    await self.hass.services.async_call("switch", "turn_off", {"entity_id": goodwe_switch})\n            else:\n                if switch_on_means_charge:\n                    await self.hass.services.async_call("switch", "turn_off", {"entity_id": goodwe_switch})\n                else:\n                    await self.hass.services.async_call("switch", "turn_on", {"entity_id": goodwe_switch})\n        except Exception as e:\n            _LOGGER.error("Failed to apply schedule to %s: %s", goodwe_switch, e)\n\ncustom_components/gw_smart_charging/sensor.py: